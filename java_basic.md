## String 类型问题

- 什么是`字符串常量池`? `常量池在哪`?

  Java为String提供了字符串常量池以提高性能, `为了减少在JVM中创建的字符串数量`, 字符串类维护了一个字符串池, 如发现字符串已经在池中则会直接返回实例, 如果没有, 就会实例化一个放到池中, 运行时实例创建的全局字符串常量池中有一个表, 总是为池中每个唯一的字符串对象维护一个引用, 这就意味着它们一直引用着字符串常量池中的对象，所以`在常量池中的这些字符串不会被垃圾收集器回收`.

  字符串常量池在JVM内存的 `方法区`

- ```String a = new String("abc"); 创建了几个对象```?

  创建了两个, "abc"字符串创建在常量池里, 同时在堆中创建了对象`a`, `a`的值是常量池字符串 `abc`
  
- String 为什么是不可变的?

  提供多线程下的安全性, 使用常量池节省内存空间
  
- String 字符串拼接为什么效率低

  每次 "+" 运算都会产生一个StringBuilder对象, 运行 append方法后回收, 合理运用 StringBuilder 有效节省内存开销及运行效率
  
- `String a = "ab"; String b = "a" + "b"; a == b 是否相等`

  相同, 编译器会直接把 `String b = "a" + "b";` 转换成 `String b = "ab";`

- `String a  = "ab"; String b  = new String("ab"); a == b 结果是什么`

  结果是 `false`, 因为 b 使用 `new` 关键字, 生成对象的地址在堆中, 而 a 则是字面量写法, 直接指向常量池
  
## 对象比较

- equals() 和 == 的区别？

  equals 方法比较的是对象值(通常是 hash code 值), == 比较的是对象内存地址, 是否是同一个对象
  
- 两个对象值相同(x.equals(y) == true)，但是可能存在hash code不同吗?

  不可能, equals() 判断的依据就是 hash code, 但如果两个对象的hash code 相同, 他们不一定相同

  

  

  
